# SWorld Backend - Project Rules

## Project Overview

This is a TypeScript-based Node.js backend for the SWorld platform, built as a microservices architecture running on Google Cloud Platform. The system consists of three main services: Gateway, Compute, and I/O, orchestrated through Cloud Tasks.

## Architecture

- **Gateway Service**: API endpoints and task routing
- **Compute Service**: Heavy computation task handlers
- **I/O Service**: Input/output and data processing task handlers
- **External Integration**: Hasura GraphQL Engine for events/triggers
- **Infrastructure**: Google Cloud Run + Cloud Tasks

## Development Standards

### Code Style & Formatting

- Use Biome for both linting and formatting (configured in `biome.json`)
- Single quotes for JavaScript/TypeScript strings
- Space indentation (2 spaces)
- Recommended linting rules enabled by default
- Automatic import organization enabled
- Run `npm run format` to format code automatically
- Run `npm run lint` to check for linting issues
- Always ensure code passes Biome checks before committing

### TypeScript Guidelines

- Strict mode enabled - maintain type safety
- Use ES2020 modules with ESNext target
- Prefer explicit typing over `any`
- Use Zod for runtime type validation
- Organize imports consistently

### File Structure & Naming

- Service entry points: `gateway.ts`, `compute.ts`, `io.ts`
- Test files: `*.test.ts` alongside source files
- Database modules in `/database` directory
- Schema definitions in `/schema` directory
- Use kebab-case for file names
- Use PascalCase for classes and interfaces

### Testing Standards

- Use Vitest for testing framework
- Write unit tests for all business logic
- Test files should be co-located with source files
- Maintain test coverage - run `npm run test:ci` for coverage reports
- Mock external dependencies (e.g., Sequelize in `__mocks__`)

### Environment & Configuration

- Use dotenvx for environment variable management
- Store sensitive config in environment variables
- Use structured logging with Pino
- Configure different environments (dev, staging, prod)

### Database & ORM

- Use Sequelize ORM with PostgreSQL
- Define models with proper TypeScript types
- Use migrations for schema changes
- Keep database operations in dedicated modules

### API & GraphQL

- Use GraphQL Code Generator for type generation
- Keep generated types updated with `npm run codegen`
- Use typed document nodes for GraphQL operations
- Implement proper error handling with structured responses

### Cloud Services Integration

- Use Google Cloud Storage for file operations
- Implement Cloud Tasks for asynchronous processing
- Use Sentry for error monitoring and performance tracking
- Follow GCP security best practices

### Performance & Monitoring

- Implement rate limiting on API endpoints
- Use Sentry for error tracking and performance monitoring
- Include source maps for better debugging
- Use structured logging for observability

## Development Workflow

### Running the Project

- Gateway service: `npm run dev-gateway`
- Compute service: `npm run dev-compute`
- I/O service: `npm run dev-io`
- Tests: `npm test` (watch mode) or `npm run test:ci` (CI mode)

### Git Workflow

- Use Husky pre-commit hooks for code quality
- Run Prettier formatting on staged files automatically
- Ensure tests pass before committing
- Write descriptive commit messages

### Code Generation

- Run `npm run codegen` after GraphQL schema changes
- Use watch mode for active development: `npm run watch-codegen-hasura`
- Keep generated files in version control

### Docker & Deployment

- Separate Dockerfiles for each service:
  - `Dockerfile.gateway`
  - `Dockerfile.compute`
  - `Dockerfile.io`
- Build and deploy through CI/CD pipeline
- Use Cloud Run for container orchestration

## Security Guidelines

- Validate all input data using Zod schemas
- Implement proper authentication and authorization
- Use Helmet for security headers
- Enable CORS appropriately
- Keep dependencies updated and scan for vulnerabilities

## Code Quality Rules

- Prefer functional programming patterns where appropriate
- Use async/await over Promises for better readability
- Implement proper error handling with structured error types
- Write self-documenting code with meaningful variable names
- Keep functions small and focused on single responsibilities

## Dependencies Management

- Use exact versions in package-lock.json
- Regularly update dependencies for security patches
- Separate dev dependencies from production dependencies
- Use TypeScript types for all external libraries

## Monitoring & Debugging

- Use Pino for structured logging with pretty printing in development
- Configure Sentry for production error tracking and performance monitoring
- Include source maps for better stack traces
- Use TypeScript strict mode for compile-time error detection

## Performance Considerations

- Use Cloud Tasks for heavy computational work
- Implement proper caching strategies
- Monitor memory usage (Node.js max memory: 8192MB in VS Code settings)
- Use streaming for large file operations
- Optimize database queries and use indexes appropriately
